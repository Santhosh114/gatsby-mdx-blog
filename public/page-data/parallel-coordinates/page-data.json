{"componentChunkName":"component---src-templates-blog-post-js","path":"/parallel-coordinates/","result":{"data":{"site":{"siteMetadata":{"title":"Over Engineered Data Viz Blog","author":"Santhosh Soundararajan"}},"mdx":{"id":"794feb6b-433b-5f38-a9e3-b4b9f32a23d4","code":{"body":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _createSuper(Derived) { return function () { var Super = _getPrototypeOf(Derived), result; if (_isNativeReflectConstruct()) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar layoutProps = {};\n\nvar MDXContent = /*#__PURE__*/function (_React$Component) {\n  _inherits(MDXContent, _React$Component);\n\n  var _super = _createSuper(MDXContent);\n\n  function MDXContent(props) {\n    var _this;\n\n    _classCallCheck(this, MDXContent);\n\n    _this = _super.call(this, props);\n    _this.layout = null;\n    return _this;\n  }\n\n  _createClass(MDXContent, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          components = _this$props.components,\n          props = _objectWithoutProperties(_this$props, [\"components\"]);\n\n      return /*#__PURE__*/React.createElement(MDXTag, {\n        name: \"wrapper\",\n        components: components\n      }, /*#__PURE__*/React.createElement(ImageComponent, {\n        queryString: 'postParallelHead',\n        widthProp: 700,\n        label: \"a simple scatter plot - \",\n        link: ['DataViz UIUC', 'https://www.coursera.org/learn/datavisualization']\n      }), /*#__PURE__*/React.createElement(MDXTag, {\n        name: \"h3\",\n        components: components\n      }, \"Why parallel coordinates?\"), /*#__PURE__*/React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"As we add more that 2 coordinates to any data representation we are going to face problems\\non a perceptual standpoint, since the essential representation medium itself is a 2D.\"), /*#__PURE__*/React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"So Al Inselberg demonstrated the concept of parallel coordinates in the early 90s. Here is how it works.\"), /*#__PURE__*/React.createElement(ImageComponent, {\n        queryString: 'postParallel1',\n        widthProp: 600\n      }), /*#__PURE__*/React.createElement(MDXTag, {\n        name: \"h3\",\n        components: components\n      }, \"Nuts & Bolts\"), /*#__PURE__*/React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"With parallel coordinates, we\\u2019re going to take the Cartesian coordinates. We have a horizontal x-axis\\nand a vertical y-axis, and we\\u2019re going to take these axes and we\\u2019re going to make them parallel instead\\nof orthogonal, at right angles, as they usually are.\"), /*#__PURE__*/React.createElement(ImageComponent, {\n        queryString: 'postParallel2',\n        widthProp: 600\n      }), /*#__PURE__*/React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"So now the two axes are not orthogonal. They\\u2019re parallel to each other and they don\\u2019t extend from the\\nsame origin. So the origin here is horizontally at the bottom and increasing x goes up this axis,\\nincreasing y goes up this axis. So now I\\u2019ve got the data points, and I need to figure out where these data points occur.\"), /*#__PURE__*/React.createElement(ImageComponent, {\n        queryString: 'postParallel3',\n        widthProp: 600\n      }), /*#__PURE__*/React.createElement(MDXTag, {\n        name: \"p\",\n        components: components\n      }, \"We can map each point onto its corresponding position on the y-axis & its just basically dragging\\nthem across horizontally, because their position in y in this chart corresponds to their height along this y-axis.\"), /*#__PURE__*/React.createElement(ImageComponent, {\n        queryString: 'postParallel4',\n        widthProp: 600\n      }));\n    }\n  }]);\n\n  return MDXContent;\n}(React.Component);\n\nreturn MDXContent;\nMDXContent.isMDXComponent = true;"},"frontmatter":{"title":"Birth of Parallel Co-ordinates","date":"July 18, 2016"}}},"pageContext":{"slug":"/parallel-coordinates/","previous":{"code":{"scope":""},"fields":{"slug":"/precinct-critique/"},"frontmatter":{"title":"Critique on Precinct-Level Map"}},"next":{"code":{"scope":""},"fields":{"slug":"/power-law/"},"frontmatter":{"title":"Exploring Visual Perception"}}}}}